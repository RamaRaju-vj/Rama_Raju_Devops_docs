# 2.14 Validating and Mutating Admission Controllers

Admission Controllers are **policy checkpoints inside the Kubernetes API server**.  
They run **after Authentication and Authorization** and **before** an object is finally created.

Their job is simple:

- âœ… **Mutating controllers** â†’ can CHANGE the request  
- ğŸ›¡ï¸ **Validating controllers** â†’ can ALLOW or REJECT the request  

Think of them as a final **quality + security gate** for every Kubernetes object.

---

# ğŸ”„ Where They Sit in the Request Flow

![Kubernetes API Server Flow](https://kubernetes.io/images/docs/components-of-kubernetes.svg)

When you run:

```bash
kubectl apply -f pod.yaml
```

The API server processes it in this order:

1. **Authentication** â€” Who are you?
2. **Authorization (RBAC)** â€” Are you allowed?
3. **Mutating Admission Controllers** â€” Modify request if needed
4. **Validating Admission Controllers** â€” Approve or reject
5. **etcd** â€” Object stored

!!! info
    Mutation happens first, then validation checks the **final modified object**.

---

# ğŸ§ª Two Types â€” Quick Comparison

=== "ğŸ§¬ Mutating Admission Controllers"
    - Can modify objects
    - Add missing fields
    - Inject defaults
    - Add labels / sidecars
    - Runs first
    - Example: DefaultStorageClass

=== "ğŸ›¡ï¸ Validating Admission Controllers"
    - Cannot modify objects
    - Only allow or reject
    - Enforce rules
    - Block unsafe configs
    - Runs after mutation
    - Example: NamespaceLifecycle

---

# ğŸ§¬ Mutating Admission Controllers â€” Easy Example

A mutating controller can **autoâ€‘fill missing fields**.

## Example: DefaultStorageClass

You create a PVC **without** storageClassName:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: data-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

Mutating controller updates it internally to:

```yaml
spec:
  storageClassName: standard
```

!!! example
    You didnâ€™t specify it â€” Kubernetes **adds it automatically** using a mutating controller.

---

# ğŸ›¡ï¸ Validating Admission Controllers â€” Easy Example

Validating controllers **do not change anything** â€” they only approve or reject.

## Example: NamespaceLifecycle

```bash
kubectl run nginx --image=nginx -n blue
```

Result:

```
Error: namespace "blue" not found
```

Why?

- AuthN âœ…  
- AuthZ âœ…  
- Validation âŒ (namespace does not exist)

!!! note
    The request is rejected â€” nothing is modified.

---

# âš ï¸ Why Mutation Runs Before Validation

Consider two rules:

- Mutating controller â†’ create namespace if missing
- Validating controller â†’ reject if namespace missing

Correct order:

```
Mutate â†’ namespace created
Validate â†’ now it exists â†’ pass
```

Wrong order would always fail.

!!! tip
    Kubernetes always runs **mutating first, validating second**.

---

# ğŸŒ External Admission Controllers (Webhooks)

You can create your **own custom admission logic** using webhooks.

Two webhook types:

- MutatingAdmissionWebhook
- ValidatingAdmissionWebhook

Kubernetes sends the request to your webhook server â†’ your code decides.

---

# ğŸ—ï¸ Webhook Flow (Concept)

```
API Server
   â”‚
Builtâ€‘in Admission Controllers
   â”‚
Webhook Call â†’ Your Webhook Service
   â”‚
Allow / Reject / Patch
```

!!! abstract
    Your webhook server can run inside the cluster or externally.

---

# ğŸ§¾ Mutating Webhook â€” YAML Example

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: add-label-webhook
webhooks:
  - name: add-label.example.com
    clientConfig:
      service:
        name: webhook-service
        namespace: default
        path: /mutate
      caBundle: <BASE64_CA_CERT>
    rules:
      - operations: ["CREATE"]
        apiGroups: [""]
        apiVersions: ["v1"]
        resources: ["pods"]
```

Use cases:

- Add labels automatically
- Inject sidecars
- Add security context
- Set defaults

---

# ğŸ§¾ Validating Webhook â€” YAML Example

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: validate-image-webhook
webhooks:
  - name: validate.example.com
    clientConfig:
      service:
        name: webhook-service
        namespace: default
        path: /validate
      caBundle: <BASE64_CA_CERT>
    rules:
      - operations: ["CREATE"]
        apiGroups: [""]
        apiVersions: ["v1"]
        resources: ["pods"]
```

Use cases:

- Block latest tag
- Block root user containers
- Enforce labels
- Restrict registries

---

# ğŸ§  What Your Webhook Server Receives

Webhook receives an **AdmissionReview JSON** with:

- user info
- operation type
- object spec
- resource type

It must reply:

## Allow

```json
{ "allowed": true }
```

## Reject

```json
{
  "allowed": false,
  "status": { "message": "Policy violation" }
}
```

Mutating webhooks can also return a **JSON patch**.

---

# ğŸ§ª Mutation Patch Concept

Example patch instruction:

```
add â†’ /metadata/labels/user â†’ "john"
```

Result:

Pod gets label automatically before creation.

---

# âœ… Key Takeaways

!!! summary

    - Admission Controllers = final policy gate
    - Two types: Mutating and Validating
    - Mutating = modify requests
    - Validating = allow or reject only
    - Mutation runs before validation
    - Webhooks enable custom logic
    - Used for security, defaults, and governance
