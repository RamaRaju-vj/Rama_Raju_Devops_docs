# 4.04 Encrypting Secret Data at Rest

#### [Official Kubernetes Secret protection and encryption documentation](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)
!!! abstract "Important Reality"
    - Kubernetes Secrets are **not encrypted by default** â€” they are only base64-encoded.  
    !!! danger
        Base64 encoding is NOT encryption. Without encryption at rest, secrets are readable from etcd.
    - Protection comes from **how you use Secrets** and **cluster hardening practices**.

    - Encryption at rest ensures **Secret objects are encrypted before being written to etcd**.




---



# ğŸ¯ Why Encryption at Rest Matters

Without encryption at rest:

- Secrets stored in etcd are readable
- etcd backups expose credentials
- Control plane access = secret exposure
- Compliance requirements may fail

!!! success
    Production clusters should always enable encryption at rest for Secrets.

---

# ğŸ” Check If Encryption at Rest Is Already Enabled

Kubernetes API server must be started with:

```
--encryption-provider-config
```

## Check Running Process

```bash
ps -aux | grep kube-api | grep encryption-provider-config
```

=== "If Present"
    Encryption config is enabled.

=== "If Missing"
    Encryption at rest is NOT enabled.

---

## Check kube-apiserver Manifest (kubeadm clusters)

```bash
ls /etc/kubernetes/manifests/
cat /etc/kubernetes/manifests/kube-apiserver.yaml
```

Look for:

```yaml
--encryption-provider-config=
```

!!! warning
    If not present â†’ Secrets are stored unencrypted in etcd.

---

# ğŸ§  How Encryption Provider Works

Encryption is configured using:

EncryptionConfiguration

You choose:

- Which resources to encrypt
- Which encryption provider to use
- Which keys are used

Example targets:

```yaml
resources:
  - secrets
```

!!! note
    Usually encrypt Secrets only.

---

# ğŸ” Available Encryption Providers

Provider order matters â€” first provider = used for encryption.

| Provider | Security | Speed | Notes |
|----------|----------|---------|--------|
identity | none | fastest | No encryption |
aescbc | good | fast | Common choice |
aesgcm | strong | fastest | Needs rotation |
secretbox | strong | fast | Modern crypto |
kms v2 | strongest | fast | External KMS (best) |

!!! warning
    If identity is first â†’ NOTHING is encrypted.

!!! tip
    Production: prefer KMS v2 or aescbc minimum.

---

# ğŸ§¾ Encryption Config File Example

```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: BASE64_KEY
      - identity: {}
```

!!! note
    First provider encrypts. Others are used for decrypt fallback.

---

# ğŸ”‘ Generate Encryption Key

```bash
head -c 32 /dev/urandom | base64
```

---

# ğŸ“ Place Config on Control Plane

```bash
mkdir -p /etc/kubernetes/enc
```

Save as:

```
/etc/kubernetes/enc/enc.yaml
```

---

# âš™ï¸ Enable Encryption in kube-apiserver

Edit:

```
/etc/kubernetes/manifests/kube-apiserver.yaml
```

Add:

```yaml
--encryption-provider-config=/etc/kubernetes/enc/enc.yaml
```

## Volume Mount

```yaml
volumeMounts:
- name: enc
  mountPath: /etc/kubernetes/enc
  readOnly: true
```

## Volume

```yaml
volumes:
- name: enc
  hostPath:
    path: /etc/kubernetes/enc
    type: DirectoryOrCreate
```

---

# ğŸ”„ Restart API Server

Static pod restarts automatically after manifest edit.

Verify:

```bash
ps -aux | grep kube-apiserver
```

---

# ğŸ§ª Verify Encryption Works

Create secret:

```bash
kubectl create secret generic my-secret --from-literal=key=topsecret
```

Check etcd:

```bash
ETCDCTL_API=3 etcdctl get /registry/secrets/default/my-secret | hexdump -C
```

Encrypted â†’ value not readable.

---

# ğŸ” Encrypt Existing Secrets

Encryption applies only to new writes.

Re-encrypt:

```bash
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```

---



### âœ… Best Practices That Make Secrets Safer

!!! success "Recommended Practices"

    - Do NOT hard-code credentials inside container images or Pod specs
    - Do NOT commit Secret YAML files with real values to Git
    - Enable **Encryption at Rest** for Secrets in etcd
    - Apply **RBAC** to strictly control Secret access
    - Limit who can run `kubectl get secret -o yaml`
    - Use separate namespaces and least-privilege access

---

### âš™ï¸ How Kubernetes Handles Secrets Securely at Runtime

!!! info "Built-in Runtime Protections"

    - Secrets are sent to a node **only if a Pod on that node needs them**
    - kubelet stores Secrets in **tmpfs (memory)** â€” not written to disk
    - Secret data is **not persisted to node storage**
    - When the dependent Pod is deleted â†’ kubelet **removes the Secret copy**
    - Secrets are not automatically shared across Pods

---

### âš ï¸ What Secrets Do NOT Protect You From

!!! warning "Know the Limits"

    - Base64 encoding is reversible
    - Anyone with etcd access can read Secrets (unless encryption at rest is enabled)
    - Cluster-admin users can read all Secrets
    - etcd backups contain Secret data
    - Secret manifests with values are risky in Git repos

---

### ğŸ­ Better Production-Grade Secret Solutions

!!! tip "Stronger Options for Sensitive Data"

    Use external or encrypted secret systems for high-security environments:

    - HashiCorp Vault
    - Cloud Secret Managers (AWS / GCP / Azure)
    - Kubernetes Secrets Store CSI Driver
    - Helm Secrets plugin
    - Mozilla SOPS + GitOps workflows

---




# ğŸ­ Production Best Practices

!!! success
    Use KMS v2 when available
!!! success
    Rotate keys regularly
!!! success
    Restrict etcd access
!!! success
    Enable etcd TLS
!!! success
    Protect encryption config file

---

# âŒ Donâ€™ts

!!! danger
    Do not leave identity first
!!! danger
    Do not store keys in Git
!!! danger
    Do not skip rotation
!!! danger
    Do not expose etcd

---

# âœ… Quick Summary

!!! summary

    - Secrets are not encrypted by default
    - Enable encryption-provider-config
    - Encrypt secrets resource
    - Provider order matters
    - Verify via etcdctl
    - Rewrite old secrets
    - Use KMS in production
