
# 4.05 Multi Container Pods

Multi-container Pods allow **multiple containers to run inside a single Kubernetes Pod** when they must be tightly coupled and operate together.

Instead of merging everything into one large container image, Kubernetes lets you package helper components alongside the main application container.

Typical real-world examples:

- App + reverse proxy
- App + log shipper
- App + metrics exporter
- App + config reloader
- App + dependency checker
- App + service mesh proxy

---

# ğŸ¯ What Makes Multi-Container Pods Special

Containers inside the same Pod share:

- âœ… Lifecycle (start and stop together)
- âœ… Network namespace (same IP, use `localhost`)
- âœ… Storage volumes
- âœ… Scheduling & node placement
- âœ… Restart behavior

!!! success
    Multi-container Pods are meant for **tightly coupled helper containers**, not unrelated services.

---

# ğŸ§  When You SHOULD Use Multi-Container Pods

Use multi-container Pods when containers must:

- Always run together
- Scale together
- Share files directly
- Communicate via localhost
- Be deployed as one unit

!!! warning
    If components can scale independently â†’ use **separate Deployments**, not one Pod.

---

# ğŸ§± Basic Multi-Container Pod Example

The `containers` field is a list â€” this allows multiple containers in one Pod.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: simple-webapp
spec:
  containers:
    - name: web-app
      image: web-app
      ports:
        - containerPort: 8080

    - name: main-app
      image: main-app
```

Behavior:

- Both containers start together
- Both run together
- Both stop together
- No startup order guarantee

!!! note
    Kubernetes does not guarantee which container starts first in this pattern.

---

# ğŸ§© Multi-Container Pod Design Patterns

There are three core patterns you must know:

1. Coâ€‘Located Containers
2. Init Containers
3. Sidecar Containers

---

# 1ï¸âƒ£ Coâ€‘Located Containers Pattern

Two or more containers:

- Run for full Pod lifecycle
- No guaranteed startup order
- All are long-running

Use when:

- Containers depend on each other
- No strict startup sequencing required

```yaml
spec:
  containers:
    - name: app
      image: app-image

    - name: helper
      image: helper-image
```

!!! note
    Good for helper daemons, lightweight proxies, or tightly bound services.

---

# 2ï¸âƒ£ Init Containers Pattern

Init containers run **before** main containers start.

Rules:

- Must complete successfully
- Run sequentially
- Main containers wait until init completes

Used for:

- Database readiness checks
- Schema migrations
- Config downloads
- Dependency validation

---

## ğŸ›  Init Container â€” DB Readiness Template

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  initContainers:
    - name: db-wait
      image: busybox
      command:
        - sh
        - -c
        - >
          until nc -z db-service 5432;
          do echo "Waiting for DB...";
          sleep 2;
          done

  containers:
    - name: app
      image: my-app
```

!!! tip
    Prefer init containers over sleep loops inside your main app.

---

## ğŸ”„ Multiple Init Containers â€” Ordered Execution

Init containers run one-by-one in order:

```yaml
initContainers:
  - name: db-checker
    image: busybox
    command: ["sh","-c","./wait-for-db.sh"]

  - name: api-checker
    image: busybox
    command: ["sh","-c","./wait-for-api.sh"]
```

Execution order:

```
db-checker â†’ api-checker â†’ main container
```

---

# 3ï¸âƒ£ Sidecar Containers Pattern

Sidecar containers:

- Run alongside main container
- Support main container
- Run for full Pod lifecycle
- Provide helper capabilities

Used for:

- Log shipping
- Metrics exporting
- Security monitoring
- Config reloaders
- Service mesh proxies

!!! success
    Sidecars extend app behavior without modifying app code.

---
## ğŸ§± Sidecar Pattern â€” Logging Example

A common production use case:

**App + Log Shipper Sidecar**

Flow:

```
App â†’ writes logs â†’ shared volume â†’ sidecar ships logs â†’ Elasticsearch â†’ Kibana
```

This ensures:

- Startup logs captured
- Runtime logs streamed
- Crash/termination logs preserved

---

## âš™ï¸ Sidecar Pattern YAML 

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: simple-webapp
  labels:
    name: simple-webapp
spec:
  containers:
    - name: web-app
      image: web-app
      ports:
        - containerPort: 8080

  initContainers:
    - name: log-shipper
      image: busybox
      command: 'setup-log-shipper.sh'
      restartPolicy: Always

```

---

## ğŸ” About restartPolicy

- `restartPolicy`  set to always for Sidecar Pattern in Init Containers.
So this will also ensure the init container is terminated after the main application stops.

- That way the log shipper can catch the startup and termination logs of the main container.
  
##### Valid restartPolicy values:

  - Always 
  - OnFailure
  - Never


---

## ğŸ§  Sidecar vs Init Container â€” Difference

| Feature | Init Container | Sidecar Container |
|----------|----------------|-------------------|
Runs before app | âœ… | âœ… |
Stops before app starts | âœ… | âŒ |
Runs during app lifecycle | âŒ | âœ… |
Used for | Setup / checks | Continuous support |

!!! note
    Init containers execute setup tasks and terminate, while sidecars provide continuous support services and run as long as the Pod is running.

---

## ğŸš€ Production Use Cases

- Log shippers (Fluent Bit, Filebeat)
- Metrics exporters
- Security agents
- Service mesh proxies (Envoy)
- Config reload helpers


---

# ğŸ§ª Troubleshooting Multi-Container Pods

Always debug per-container.

## Describe Pod

```bash
kubectl describe pod <pod>
```

## Logs per container

```bash
kubectl logs <pod> -c app
kubectl logs <pod> -c sidecar
```

## Exec into specific container

```bash
kubectl -n elastic-stack exec -it app -- cat /log/app.log 
# Pod Name: app
# Command to execute: cat /log/app.log
```

!!! tip
    Most â€œPod failuresâ€ are actually **one container failing**.

---

# ğŸ­ Production Best Practices

!!! success
    Keep each container single-purpose

!!! success
    Use init containers for readiness logic

!!! success
    Use sidecars for logging & metrics

!!! success
    Define resource limits per container

!!! success
    Add readiness & liveness probes

!!! success
    Use shared volumes carefully

---

# âŒ Production Donâ€™ts

!!! danger
    Do not group unrelated services

!!! danger
    Do not assume container start order

!!! danger
    Do not put business logic in sidecars

!!! danger
    Do not skip health probes

---
