# 4.03 Configure Env Variables,ConfigMaps & Secrets in Applications

Kubernetes lets you pass configuration into containers using:

- Environment variables
- ConfigMaps
- Secrets

This keeps configuration **separate from container images** and makes apps easier to manage and update.

---

## ğŸ¯ Why Use Environment Configuration

Applications often need runtime configuration such as:

- App mode (dev / prod)
- Feature flags
- Colors / themes
- DB hostnames
- Ports
- External service URLs

Hard-coding these inside images is bad practice.

!!! success
    Kubernetes supports external configuration using **env**, **ConfigMaps**, and **Secrets**.

---

# ğŸ§ª Basic Environment Variable in a Pod

Equivalent Docker command:

```bash
docker run -e APP_COLOR=pink simple-webapp-color
```

Kubernetes Pod YAML:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: simple-webapp-color
spec:
  containers:
    - name: app
      image: simple-webapp-color
      ports:
        - containerPort: 8080
      env:
        - name: APP_COLOR
          value: pink
```

!!! note
    `env` is a list â€” each variable is a separate item.

---

# ğŸ§© Environment Value Sources (3 Ways)

Kubernetes supports three env value types:

1. Plain key/value  
2. ConfigMap  
3. Secret  

=== "Plain Key Value"

    ```yaml
    env:
      - name: APP_COLOR
        value: pink
    ```

=== "From ConfigMap"

    ```yaml
    env:
      - name: APP_COLOR
        valueFrom:
          configMapKeyRef:
            name: app-config
            key: APP_COLOR
    ```

=== "From Secret"

    ```yaml
    env:
      - name: DB_PASSWORD
        valueFrom:
          secretKeyRef:
            name: db-secret
            key: password
    ```

---

# ğŸ—‚ï¸ What Is a ConfigMap

A ConfigMap stores configuration as **keyâ€“value pairs** in Kubernetes.

Benefits:

- Central config storage
- Reusable across Pods
- No image rebuild required
- Easy updates

!!! abstract
    ConfigMap = configuration outside the container image.

---

# âœï¸ Create ConfigMap â€” Imperative Method

## From Literal Values

```bash
kubectl create configmap app-config \
  --from-literal=APP_COLOR=blue \
  --from-literal=APP_MODE=prod
```

---

## From File

```bash
kubectl create configmap app-config \
  --from-file=app.properties
```

---

# ğŸ“„ Create ConfigMap â€” Declarative Method

ConfigMap YAML:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  APP_COLOR: blue
  APP_MODE: prod
```

Create:

```bash
kubectl apply -f configmap.yaml
```

---

# ğŸ” View ConfigMaps

```bash
kubectl get configmaps
kubectl describe configmap app-config
```

---

# ğŸš€ Inject ConfigMap into Pod â€” All Keys

Load all keys as environment variables:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webapp
spec:
  containers:
    - name: app
      image: simple-webapp-color
      envFrom:
        - configMapRef:
            name: app-config
```

Result inside container:

```
APP_COLOR=blue
APP_MODE=prod
```

!!! tip
    `envFrom` loads **all keys** from the ConfigMap.

---

# ğŸ¯ Inject Single ConfigMap Key

```yaml
env:
  - name: APP_COLOR
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: APP_COLOR
```

!!! note
    Use this when you only need specific keys.

---

# ğŸ’¾ Inject ConfigMap as Volume

ConfigMap can also be mounted as files.

```yaml
volumes:
  - name: config-vol
    configMap:
      name: app-config

containers:
  - name: app
    image: simple-webapp-color
    volumeMounts:
      - name: config-vol
        mountPath: /etc/config
```

Result inside container:

```
/etc/config/APP_COLOR
/etc/config/APP_MODE
```

---

# âš ï¸ When to Use Secrets Instead

Use **Secrets** instead of ConfigMaps for:

- Passwords
- Tokens
- Keys
- Certificates

!!! warning
    ConfigMaps are NOT encrypted â€” Secrets are.

---

# â“ Exam-Style Checks

!!! question
    Where is ConfigMap data stored?

In Kubernetes API (etcd).

!!! question
    Does ConfigMap require Pod restart after change?

Usually yes (unless app reloads dynamically).

!!! question
    Can ConfigMap be used as files?

Yes â€” via volume mount.

---

# âœ… Quick Summary

!!! summary

    - Use env for simple variables
    - Use ConfigMaps for shared configuration
    - Create via kubectl or YAML
    - Inject using env, envFrom, or volumes
    - envFrom loads all keys
    - configMapKeyRef loads one key
    - Use Secrets for sensitive data

---

# Kubernetes Secrets

Kubernetes **Secrets** are used to store and manage **sensitive data** such as:

- Passwords
- API keys
- Tokens
- Database credentials

Secrets are similar to ConfigMaps â€” but meant for **confidential values**.

---

# ğŸ¯ Why Secrets Are Needed

Hard-coding credentials inside application code or Pod YAML is unsafe.

Example (âŒ bad practice):

```python
mysql.connect(
  host="mysql",
  user="root",
  password="passwd"
)
```

Instead â€” move sensitive values into **Kubernetes Secrets** and inject them securely.

!!! warning
    Do NOT store passwords in Pod specs or container images.

---

# ğŸ§  Secrets vs ConfigMaps

| Feature | ConfigMap | Secret |
|---------|------------|----------|
Purpose | Non-sensitive config | Sensitive data |
Storage | Plain text | Base64 encoded |
Use case | App settings | Credentials, keys |

!!! note
    Secrets are base64-encoded â€” not encrypted by default.

---

# ğŸ” Secret Workflow (2 Steps)

```
Step 1 â†’ Create Secret
Step 2 â†’ Inject into Pod
```

Secrets can be injected as:

- Environment variables
- Single env values
- Mounted volume files

---

# âš™ï¸ Create Secrets â€” Imperative Method

## From Literal Values

```bash
kubectl create secret generic app-secret \
  --from-literal=DB_Host=mysql \
  --from-literal=DB_User=root \
  --from-literal=DB_Password=passwd
```

---

## From File

```bash
kubectl create secret generic app-secret \
  --from-file=secret.properties
```

!!! tip
    Good when many secret keys exist.

---

# ğŸ“¦ Create Secrets â€” Declarative Method

Secrets YAML requires **base64 encoded values**.

## Encode Values

```bash
echo -n 'mysql' | base64
echo -n 'root' | base64
echo -n 'passwd' | base64
```

---

## Secret YAML

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
type: Opaque
data:
  DB_Host: bXlzcWw=
  DB_User: cm9vdA==
  DB_Password: cGFzc3dk
```

Apply:

```bash
kubectl apply -f secret.yaml
```

!!! success
    Declarative method is preferred for GitOps.

---

# ğŸ” View Secrets

## List

```bash
kubectl get secrets
```

## Describe (values hidden)

```bash
kubectl describe secret app-secret
```

## View YAML (encoded values visible)

```bash
kubectl get secret app-secret -o yaml
```

---

# ğŸ”“ Decode Secret Value

```bash
echo 'bXlzcWw=' | base64 --decode
```

!!! note
    Base64 encoding is reversible â€” enable etcd encryption for real security.

---

# ğŸš€ Inject Secrets into Pods â€” All as ENV

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-pod
spec:
  containers:
    - name: app
      image: myapp
      envFrom:
        - secretRef:
            name: app-secret
```

Result inside container:

```
DB_Host
DB_User
DB_Password
```

---

# ğŸ¯ Inject Single Secret Key

```yaml
env:
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: app-secret
        key: DB_Password
```

!!! tip
    Use this when you only need one value.

---

# ğŸ“ Mount Secret as Volume

Each secret key becomes a file.

```yaml
spec:
  containers:
    - name: app
      image: myapp
      volumeMounts:
        - name: secret-vol
          mountPath: /opt/secrets

  volumes:
    - name: secret-vol
      secret:
        secretName: app-secret
```

Inside container:

```bash
ls /opt/secrets
cat /opt/secrets/DB_Password
```

---

# ğŸ§­ Secret Injection Diagram

```
Secret Object
   â”‚
   â”œâ”€â”€ envFrom â†’ all keys â†’ env vars
   â”‚
   â”œâ”€â”€ secretKeyRef â†’ single key â†’ env var
   â”‚
   â””â”€â”€ volume mount â†’ keys â†’ files
```

---

# âš ï¸ Important Security Notes

!!! warning
    Base64 is encoding â€” not encryption.

!!! warning
    Enable etcd encryption for production clusters.

!!! tip
    Use RBAC to restrict secret access.

!!! tip
    Avoid committing Secret YAML with real values to Git.

---

# ğŸ§ª Exam-Style Checks

!!! question
    Are Secrets encrypted by default?

No â€” only base64 encoded.

!!! question
    How many steps to use Secrets?

Create â†’ Inject.

!!! question
    Can Secrets be used as files?

Yes â€” via volume mount.

!!! question
    Which field injects all keys as env vars?

envFrom + secretRef

---

# âœ… Quick Summary

!!! summary

    - Secrets store sensitive data
    - Similar to ConfigMaps but for credentials
    - Values stored base64 encoded
    - Create via imperative or YAML
    - Inject using envFrom, secretKeyRef, or volumes
    - Describe hides values
    - YAML shows encoded values
    - Use RBAC + etcd encryption in production
